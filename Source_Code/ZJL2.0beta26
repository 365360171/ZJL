#!/system/bin/sh

#********************************************************
# Author: ZJL
# QQ: 1965786708
# Version: 2.0 beta26
# Date: 2020-10-13 14:00
# FileName: ZJL
# Description: 整合tiny、clnc的nat免流防跳
#********************************************************

# 防跳版本
readonly zjl_version="2.0-beta26"

# 显示帮助 []<-(errorMsg:String)
show_help() {
    echo
    # 输出错误消息
    [[ ${1} ]] && echo "Wrong: ${1}\n\n"
    
    echo "ZJL 防跳 ${zjl_version}，作者: ZJL(龍哥)"
    echo "QQ: 1965786708，发现BUG请加我反馈\n"
    
    echo "Usage: ZJL [-o/-c]"
    echo "   or: ZJL [-o/-c] [-d]"
    echo "   or: ZJL [-o/-c] [-d] [-i]"
    echo "   or: ZJL [-d]"
    echo "   or: ZJL [-d] [-i]"
    echo "   or: ZJL [-h]"
    echo "   or: ZJL [-v]\n"
    
    echo "-o or --open         开启防跳"
    echo "-c or --close        关闭防跳"
    echo "-d or --display      显示输出界面"
    echo "-i or --info         显示所有信息"
    echo "-h or --help         查看帮助"
    echo "-v or --version      查看版本\n"
    
    echo "最多支持三个有效选项"
    echo "-o 和 -c 二选一 不可同时选择"
    echo "-h 和 -v 单独使用 例: ZJL -h"
    
    exit
}


# 读取配置 = 号后面的内容 [String]<-(arg:String)
get_configure() {
    echo "`echo "${configure_file_content}" | sed -n 's/'${1}'=[ \t]*//p'`"
}


# 获取模式指定的的端口 [int]<-(arg:String)
get_confPort() {
    echo "`echo "${mode_listen_port_list}" | grep -w "${1}" | sed "s/.*://" | grep -o "[0-9][0-9]*"`"
}


# 通过包名读取应用UID [int]<-(packageName:String)
get_package_uid() {
    # 包名列表内容为空就读取
    [[ ! ${packages} ]] && packages="`sed -r 's/([^ ]*) ([0-9]*) .*/\1 \2/g' /data/system/packages.list`"
    echo "`echo "$packages" | grep -w "${1}" | sed 's/.*[ \t]//'`"
}


# 读取模式及端口 []<-() 
read_mode_port() {
    # 读取模式内容 去除了空行以及//和#开头的内容
    mode_file_content="`sed 's/\/\/.*$//;s/#.*$//;/^[ ]*$/d' ${mode_file}`"
    # 读取模式内带有端口内容的行
    mode_listen_port_list="`echo "${mode_file_content}" | grep "listen"`"
    
    # 判断核心是否为clnc 模式是否开启UDP
    if [[ "clnc" == ${unlimited_data_way} && `echo "${mode_file_content}" | grep -i "httpUDP"` ]]; then
        # 读取UDP转发端口
        udp_forward_port="`get_confPort udp_tproxy_listen`"
        
        # 判断是否开启代理 UDP
        if [[ ${udp_forward_port} ]]; then
            if [[ ! `grep -q 'TPROXY' /proc/net/ip_tables_targets` ]]; then
                [[ "代理" == ${native_udp} && "放行" != ${release_native_uid} && "禁网" != ${ban_native_uid} ]] && proxy_native_udp="true"
                [[ "代理" == ${hotspot_udp}  && "放行" != ${hotspot_network} && "禁网" != ${hotspot_network} ]] && proxy_hotspot_udp="true"
            else
                is_udp_supported="false"
            fi
        fi
    fi
}


# 输出分割线 []<-()
output_dividing_line() {
    center_output "${dividing_line}"
}


# 获取传入的网卡所使用的流量 []<-(network_card:String)
get_network_card_traffic() {
    # 判断是否存在busybox
    if [[ ${is_busybox_exist} ]]; then
        # 获取网卡使用的流量
        local flow="`ifconfig ${1} | grep -i 'RX bytes' | sed 's/.*RX bytes:.*(\(.*B\)).*TX.*/\1/;s/i.*//'`"
        
        # 输出流量数
        [[ "0.0 B" == ${flow} || "" == ${flow} ]] && center_output "已用: 没查到 ×\n" || center_output "已用: ${flow}\n"
    fi
}


# 开关数据流量 []<-(arg:String)
switch_network() {
    if [[ "开启" == ${on_off_network} ]]; then
        [[ "open" == ${1} ]] && svc data enable || svc data disable
    fi
}


# 放行本机UID对应的应用 []<-(uid:String)
release_uid() {
    iptables -t nat -I OUTPUT -m owner --uid ${1} -j ACCEPT
    iptables -t mangle -I OUTPUT -m owner --uid ${1} -j ACCEPT
}


# 放行指定 链&&协议&&端口组合 []<-(chain:String, protocol:String, port:int)
release_port() {
    for ZJL in ${3}; do
        iptables -t nat -I ${1} -p ${2} -m multiport --dport ${ZJL} -j ACCEPT
        iptables -t mangle -I ${1} -p ${2} -m multiport --dport ${ZJL} -j ACCEPT
    done
}


# 开机自启 []<-()
boot_auto_on() {
    # 读取配置文件内开启自启填的选项
    local option="`get_configure 开机自启`"

    # 设置实现开启自启文件的路径
    local path="/system/bin/debuggerd"
    # 设置读取是否开启自启状态文件的路径
    local read_state="/data/ZJL.sh"
        
    # 选项为 通用 且状态文件不存在，就为true
    if [[ "通用" == ${option} ]] && [ ! -s ${path}.ori ]; then
        # 把 debuggerd 重命名为 debuggerd.ori
        `mv ${path} ${path}.ori`
        # 写入内容到 debuggerd 文件
        echo '#!/system/bin/sh\nscript()\n{\n    '${read_state}'\n'\
              '   rm -f Start.log\n    for ZJL in '${read_state}'\n    do\n'\
              '       ${ZJL} &>>Start.log\n    done\n}\nscript &\n'${path}.ori'' >${path}
        # 写入防跳路径到状态文件内
        echo "#!/system/bin/sh\n${0} -o" > ${read_state}
        # 给三个要用到的文件赋上777权限
        `chmod 777 ${path} ${path}.ori ${read_state}`
        
    # 选项不为 通用 且状态文件存在的话，就为true
    elif [[ "通用" != ${option} ]] && [ -s ${path}.ori ]; then
        # 把 debuggerd.ori 重命名为 debuggerd
        `mv ${path}.ori ${path}`
        # 给 debuggerd 文件赋权限
        `chmod 755 ${path}`
        # 删除状态文件
        `rm ${read_state}`
    fi
    
    
    # 重写路径，高通自启方法
    path="/system/etc/init.qcom.post_option.sh"
    # 判断所需文件是否存在 存在就读取状态
    [ -s ${path} ] && read_state="`grep 'ZJL' ${path}`"
    
    # 选项为 高通 且状态为关闭的话，就为true
    if [[ "高通" == ${option} && "" == ${read_state} ]]; then
        # 写入防跳路径到 init.qcom.post_option.sh 文件内
        echo "\n${0} -o" >> ${path}
        
    # 选项不为 高通 且状态为开启的话，就为true
    elif [[ "高通" != ${option} && ${read_state} ]]; then
        # 删除 init.qcom.post_option.sh 文件内的防跳路径
        echo "`sed '/ZJL/d' ${path}`" > ${path}
    fi
    
    
    # 重写路径，SuperSU自启方法
    path="/su/su.d/ZJL.sh"
    
    # 选项不为 su 且自启文件不存在的话，就为true
    if [[ `echo "${games}" | grep -i "^su$"` ]] && [ ! -s ${path} ]; then
        # 写入防跳路径到自启文件
        echo "#!/system/bin/sh\n${0} -o" > ${path}
        # 给权限
        `chmod 777 ${path}`
        
    # 选项不为 su 且自启文件存在的话，就为true
    elif [[ ! `echo "${games}" | grep -i "^su$"` ]] && [ -s ${path} ]; then
        # 删除自启文件
        `rm ${path}`
    fi
    
    
    # 重写路径，面具自启方法
    path=/data/adb/service.d/ZJL.sh
    
    # 选项为 面具 且自启文件不存在的话，就为true
    if [[ "面具" == ${option} ]] && [ ! -s ${path} ]; then
        # 写入防跳路径到自启文件
        echo "#!/system/bin/sh\n${0} -o" > ${path}
        # 给权限
        `chmod 777 ${path}`
        
    # 选项不为 面具 且文件存在的话，就为true
    elif [[ "面具" != ${option} ]] && [ -s ${path} ]; then
        # 删除自启文件
        `rm ${path}`
    fi
}


# 获取指定循环次数的填充字符串 [String]<-(number:int, filler:String)
become_middle() {
    local product
    local min="1"
    local max="${1}"
    
    while [ ${min} -le ${max} ]; do
        product="${product}${2}"
        ((min++))
    done
    
    echo "${product}"
}


# 输出居中函数 [String]<-(arg:String, filler:String)
center_output() {
    local term_width="53"
    
    # 计算要居中字符串的长度
    if [[ `echo "${1}" | grep -Eo [^\x00-\xff]+ | sed 's/[[:punct:]]//g;s/ //g'` ]]; then
        local chinese="`echo "${1}" | grep -Eo [^\x00-\xff]+ | sed 's/[[:punct:]]//g;s/ //g'`"
        local chinese_length="${#chinese}"
        local english_length="$((${#1} - chinese_length))"
        ((chinese_length = ${chinese_length} * 40 / 75))
        local total_width="$((chinese_length + english_length))"
    else
        local total_width="${#1}"
    fi
    
    #计算次数
    local head_width="$((term_width - total_width))"
    [[ ${1} == ${dividing_line} ]] && head_width="$((head_width * 5 / 4))" || head_width="$((head_width / 2))"
    local end_width="$(((term_width - total_width) - head_width))"
    
    # 如果没指定填充字符串就默认为空格
    [[ ${2} ]] && local fill_field="${2}" || local fill_field=" "
    
    # 获取前后的填充字符串
    local head="`become_middle "${head_width}" "${fill_field}"`"
    local end="`become_middle "${end_width}" "${fill_field}"`"
    
    # 输出处理好的字符串
    echo "${head}${1}${end}"
}


# 内网白名单 []<-()
intranet_IP_white_list() {
    # 读取白名单设置
    for ZJL in `get_configure 内网白名单 | grep -o "[0-9][0-9.-]*"`; do
        local intranet_ip_state
        # 判断IP段是否合法 不合法结束本次循环
        [[ `echo ${ZJL} | grep -Ew '^([0-9]{1,3}.){1,3}[0-9]{1,3}(-([0-9]{1,3}.){1,3}[0-9]{1,3})?$'` ]] && intranet_ip_state=${intranet_ip_state:="true"} || continue
        
        # 判断是否为连续IP段
        if [[ `echo ${ZJL} | grep "-"` ]]; then
            iptables -t mangle -I OUTPUT -p 6 -m iprange --src-range ${ZJL} -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT
            [[ "禁网" != ${native_dns} ]] && iptables -t mangle -I OUTPUT -p 17 -m iprange --src-range ${ZJL} -m multiport --dport 53,5353 -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT
        else
            iptables -t mangle -I OUTPUT -s ${ZJL}/16 -p 6 -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT
            [[ "禁网" != ${native_dns} ]] && iptables -t mangle -I OUTPUT -s ${ZJL}/16 -p 17 -m multiport --dport 53,5353 -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT
        fi
    done
    
    # 判断是否关闭白名单功能
    if [[ ! ${intranet_ip_state} ]]; then
        # 没有开启白名单功能，默认放行所有内网规则
        iptables -t mangle -I OUTPUT -p 6 -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT
        [[ "禁网" != ${native_dns} ]] && iptables -t mangle -I OUTPUT -p 17 -m multiport --dport 53,5353 -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT
    fi
}


# 核心部分的iptables规则 []<-()
important_rules() {
    # 读取模式TCP转发端口和DNS转发端口
    if [[ "clnc" == ${unlimited_data_way} ]]; then
        tcp_forward_port="`get_confPort tcp_listen`"
        dns_forward_port="`get_confPort dns_listen`"
    else
        tcp_forward_port="`get_confPort listen_port`"
        dns_forward_port="`get_confPort dns_listen_port`"
    fi
    
    # ----- 以下为UDP网络部分规则 -----
    
    # 判断是否开启代理UDP
    if [[ ${proxy_native_udp} || ${proxy_hotspot_udp} ]]; then
        #ip路由        
        ip rule add fwmark 0x4f5da2/0xffffffff table 100
        ip route add local default dev lo table 100
        
        # 判断是否代理本机UDP
        if [[ ${proxy_native_udp} ]]; then
            iptables -t mangle -I OUTPUT -p 17 -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT
            iptables -t mangle -I OUTPUT -p 17 -j MARK --set-mark 5201314
        fi
        
        # 如果不代理不放行共享UDP的话就禁网
        [[ "" == ${proxy_hotspot_udp} && "放行" != ${hotspot_udp} ]] && iptables -t mangle -I PREROUTING -s 192.168/16 -p 17 -j DROP
        
        iptables -t mangle -I PREROUTING ! -i tun+ -p 17 -j TPROXY --on-port ${udp_forward_port} --tproxy-mark 5201314
        
        #放行网卡，否则外网IP可能无法代理UDP
        for ZJL in `ip addr | grep global | grep -E '[1-9]{1}[0-9]{0,2}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' | sed 's/inet \(.*\)\/.*/\1/'`; do
            iptables -t mangle -I PREROUTING -d ${ZJL} -j ACCEPT
        done
        
        #放行特殊IP段，否则核心做UDP回应会被TPROXY代理造成无限回环或者一些情景下无法工作
        for ZJL in 127/8 10/8 100.64/10 192.168/16 172.16/12 255/8 224/4 240/4 169.254/16; do
            iptables -t mangle -I PREROUTING -d ${ZJL} -j ACCEPT
        done
    fi
    
    # ----- 以下为本机网络部分规则 -----
    
    # 判断本机网络是否为代理或者禁网
    if [[ "放行" != ${release_native_uid} ]]; then
        # 禁mengle链
        iptables -t mangle -P OUTPUT DROP
        
        if [[ "禁网" != ${ban_native_uid} ]]; then
            # 内网白名单
            intranet_IP_white_list
            
            # 如果不代理UDP就执行本条
            [[ ! ${proxy_native_udp} ]] && iptables -t nat -I OUTPUT -j REDIRECT
            # 转发 TCP
            iptables -t nat -I OUTPUT -p 6 -j REDIRECT --to ${tcp_forward_port}
            # 判断本机DNS是否为代理
            if [[ "放行" != ${native_dns} && "禁网" != ${native_dns} ]]; then
                local custom_native_dns="`echo ${native_dns} | grep -Ew '^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'`"
                
                # 判断是否为自定义DNS
                if [[ ${custom_native_dns} ]]; then
                    iptables -t nat -I OUTPUT -p 17 -m multiport --dport 53,5353 -j DNAT --to ${custom_native_dns}
                else
                    iptables -t nat -I OUTPUT -p 17 -m multiport --dport 53,5353 -j REDIRECT --to ${dns_forward_port}
                fi
            fi
            
            # 放行核心GID
            iptables -t nat -I OUTPUT -m owner --gid ${forward_gid} -j ACCEPT
        fi
    fi
    
    
    # ----- 以下为共享网络部分规则 -----
    
    # 判断共享网络是否为代理或者禁网
    if [[ "放行" != ${hotspot_network} ]]; then
        # 禁网 FORWARD 链
        iptables -t mangle -P FORWARD DROP
        
        # 判断共享网络是否为代理
        if [[ "禁网" != ${hotspot_network} ]]; then
            # 共享网络规则
            iptables -t mangle -I PREROUTING -s 192.168/16 -m state --state INVALID -j DROP
            
            # 如果不代理UDP就执行本条
            [[ ! ${proxy_hotspot_udp} ]] && iptables -t nat -I PREROUTING -s 192.168/16 -j REDIRECT
            # 转发 TCP
            iptables -t nat -I PREROUTING -s 192.168/16 -p 6 -j REDIRECT --to ${tcp_forward_port}
            # 判断共享DNS是否为禁网
            if [[ "禁网" == ${hotspot_dns} ]]; then
                iptables -t mangle -I PREROUTING -s 192.168/16 -p 17 -m multiport --dport 53,5353 -j DROP
            else
                # 判断共享DNS是否为代理
                [[ "放行" != ${hotspot_dns} ]] && iptables -t nat -I PREROUTING -s 192.168/16 -p 17 -m multiport --dport 53,5353 -j REDIRECT --to 53
            fi
        fi
    fi
    
    # 放行本机网卡
    for ZJL in $(get_configure 放行网卡); do
        iptables -t nat -I OUTPUT -o ${ZJL} -j ACCEPT
        iptables -t mangle -I OUTPUT -o ${ZJL} -j ACCEPT
    done
    
    iptables -t nat -I OUTPUT -d 192.168/16 -j ACCEPT
    iptables -t mangle -I OUTPUT -d 192.168/16 -j ACCEPT
    iptables -t nat -I PREROUTING -d 192.168/16 -j ACCEPT
}


# 游戏流量规则 []<-()
game_rules() {
    # 读取游戏配置
    local games="`get_configure 本机游戏`"
    # 代理则返回
    [[ ! `echo ${games} | grep -Ei "^(放行UID|放行UDP|禁网)$"` ]] && return
    
    # 预设一个局部变量存游戏UID
    local uid
    
    # 游戏包名 游戏列表：王者荣耀，QQ飞车，CF，和平精英，火影忍者，第五人格网易版，明日之后网易版
    for ZJL in com.tencent.tmgp.sgame com.tencent.tmgp.speedmobile com.tencent.tmgp.cf \
    com.tencent.tmgp.pubgmhd com.tencent.KiHan com.netease.mrzh com.netease.dwrg; do
        uid="`get_package_uid ${ZJL}`"
        [[ ! ${uid} ]] && continue
        
        if [[ `echo "${games}" | grep -i "^放行UID$"` ]]; then
            release_uid "${uid}"
        elif [[ "禁网" == ${games} ]]; then
            iptables -t mangle -I OUTPUT -m owner --uid ${uid} -j DROP
        else
            iptables -t nat -I OUTPUT -p 17 -m owner --uid ${uid} -j ACCEPT
            iptables -t mangle -I OUTPUT -p 17 -m owner --uid ${uid} -j ACCEPT
        fi
    done
}


# 次要部分的iptables规则 []<-()
not_important_rules() {
    # ----- 以下为本机网络部分规则 -----
    
    # 游戏iptables规则
    game_rules
    
    # 放行本机UID对应的应用
    if [[ "放行" != ${release_native_uid} ]]; then
        for ZJL in ${release_native_uid}; do
            release_uid "${ZJL}"
        done
    fi
    
    # 禁止本机UID对应的软件的网
    if [[ "禁网" != ${ban_native_uid} ]]; then
        for ZJL in ${ban_native_uid}; do
            iptables -t mangle -I OUTPUT -m owner --uid ${ZJL} -j DROP
        done
    fi
    
    # 判断是否放行本机UDP
    if [[ "放行" == ${native_udp} ]]; then
        iptables -t nat -I OUTPUT -p 17 -j ACCEPT
        iptables -t mangle -I OUTPUT -p 17 -j ACCEPT
    fi
    
    # 放行本机UID对应的软件的UDP
    for ZJL in `get_configure 放行UDP`; do
        iptables -t nat -I OUTPUT -m owner --uid ${ZJL} -p 17 -j ACCEPT
        iptables -t mangle -I OUTPUT -m owner --uid ${ZJL} -p 17 -j ACCEPT
    done
    
    local release_native_https="`get_configure 放行HTTPS`"
    # 放行本机HTTPS
    if [[ "放行" == ${release_native_https} ]]; then
        iptables -t nat -I OUTPUT -p 6 --dport 443 -j ACCEPT
        iptables -t mangle -I OUTPUT -p 6 --dport 443 -j ACCEPT
        
    else
        # 放行本机UID对应的软件的HTTPS
        for ZJL in `echo "${release_native_https}" | grep -o [0-9][0-9]*`; do
            iptables -t nat -I OUTPUT -p 6 --dport 443 -m owner --uid ${ZJL} -j ACCEPT
            iptables -t mangle -I OUTPUT -p 6 --dport 443 -m owner --uid ${ZJL} -j ACCEPT
        done
    fi
    
    # 根据包名放行本机UID对应的软件的流量
    for ZJL in `get_configure 放行包名`; do
        for uid in `get_package_uid ${ZJL}`; do
            [[ "" == ${uid} ]] && continue || release_uid "${uid}"
        done
    done
    
    # 放行（QQ && TIM && 微信）的 UDP 8000 端口，为网络电话使用的端口
    if [[ "放行" == "`get_configure QQ微信电话`" ]]; then
        for ZJL in tencent.mobileqq tencent.tim tencent.mm; do
            uid=`get_package_uid ${ZJL}`
            [[ "" == ${uid} ]] && continue
            
            iptables -t nat -I OUTPUT -p 17 --dport 8000 -m owner --uid ${uid} -j ACCEPT
            iptables -t mangle -I OUTPUT -p 17 --dport 8000 -m owner --uid ${uid} -j ACCEPT
        done
    fi
    
    # 放行本机TCP端口
    release_port "OUTPUT" "6" "`get_configure 放行TCP端口 | sed 's/[ ][ ]*/,/g'`"
    
    # 放行本机UDP端口
    release_port "OUTPUT" "17" "`get_configure 放行UDP端口 | sed 's/[ ][ ]*/,/g'`"
    
    # 判断是否放行本机DNS
    [[ "放行" == ${native_dns} ]] && iptables -t nat -I OUTPUT -p 17 -m multiport --dport 53,5353 -j ACCEPT
    
    
    # ----- 以下为共享网络部分规则 -----
    
    # 判断是否放行共享UDP
    if [[ "放行" == ${hotspot_udp}  ]]; then
        iptables -t mangle -I FORWARD -p 17 -j ACCEPT
        iptables -t nat -I PREROUTING -s 192.168/16 -p 17 -j ACCEPT
    fi
    
    hotspot_https="`get_configure 共享HTTPS`"
    if [[ "放行" == ${hotspot_https} ]]; then
        iptables -t mangle -I FORWARD -p 6 --dport 443 -j ACCEPT
        iptables -t nat -I PREROUTING -s 192.168/16 -p 6 --dport 443 -j ACCEPT
        
    elif [[ "禁网" == ${hotspot_https} ]]; then
        iptables -t mangle -I PREROUTING -s 192.168/16 -p 6 --dport 443 -j DROP
    fi
    
    # 放行共享TCP端口
    release_port "PREROUTING -s 192.168/16" "6" "`get_configure 共享TCP端口 | sed 's/[ ][ ]*/,/g'`"
    
    # 放行共享UDP端口
    release_port "PREROUTING -s 192.168/16" "17" "`get_configure 共享UDP端口 | sed 's/[ ][ ]*/,/g'`"
}


# 初始化 [Boolean]<-()
init_zjl() {
    # 防跳路径
    zjl_path="${0%/*/*}"
    # 模式路径
    mode_path="${0%/*/*}"
    # 模块路径
    module_path="${0%/*}"
    # 切换当前路径为防跳路径
    cd ${zjl_path}
    
    # 处理模块路径括号问题
    module_path="${module_path//\(/\\(}"
    module_path="${module_path//\)/\\)}"
    
    # 判断模块文件夹是否存在busybox 没有将使用系统的
    [ -s ${module_path}/busybox ] && alias busybox="${module_path}/busybox"
    
    # 脚本运行所需命令
    local command_requireds="mv rm ip sed find grep chmod pkill pgrep ifconfig"
    # 防跳配置文件路径
    local ini_path="${zjl_path%/*}/.ZJL.ini"
                    
    # 判断是否存在busybox
    if [[ `busybox --help` ]]; then
        for ZJL in ${command_requireds}; do
            # 设置命令别名
            alias ${ZJL}="busybox ${ZJL}"
        done
        
        # 表示当前脚本找到了busybox
        is_busybox_exist="true"
        `rm ${ini_path}`
    else
        # 表示当前脚本找不到busybox，将使用系统自带命令
        
        # 读取是否存在配置文件
        if [[ ! `grep "command=" ${ini_path}` ]]; then
            # 读取系统是否存在脚本运行所需命令 如果有一个命令不存在就退出脚本
            if [[ `type ${command_requireds} | grep not found` ]]; then
                # 输出提示
                echo "\n      —————————————————————————\n\n"\
                      "              ZJL 2.0\n\n"\
                      "          无busybox启动失败\n\n"\
                      "     —————————————————————————\n\n"\
                      "          手机需内置以下命令\n\n"\
                      "            mv rm ip sed\n\n"\
                      "          find grep pkill\n\n"\
                      "        pgrep chmod ifconfig\n\n"\
                      "          所以请安装busybox\n\n"\
                      "         或复制到模块文件夹里\n\n"\
                      "     —————————————————————————"
                # 退出函数
                return 1
            fi
            
            # 如果命令都存在，则写入配置文件
            echo "command=\"ON\"" > ${ini_path}
            # 文件赋权限
            `chmod 777 ${ini_path}`
        fi
    fi
    
    for ZJL in ${zjl_path} ${mode_path} ${module_path}; do
        # 删除bak后缀备份文件
        `rm -f ${ZJL}/*.bak`
        # 赋予文件权限
        `chmod -R 777 ${ZJL}`
    done
    
    # 读取防跳配置文件，并过滤以 // 和 # 为开头的注释内容
    configure_file_content="`sed 's/\/\/.*$//;s/#.*$//;s/[ \t]*$//;s/[ ][ ]*/ /g;/^[ ]*$/d' ${zjl_path}/*.ini`"
    
    # 读取配置
    release_native_uid="`get_configure 放行UID`"
    ban_native_uid="`get_configure 禁网UID`"
    native_udp="`get_configure 本机UDP`"
    native_dns="`get_configure 本机DNS`"
    hotspot_network="`get_configure 共享网络`"
    hotspot_udp="`get_configure 共享UDP`"
    hotspot_dns="`get_configure 共享DNS`"
    unlimited_data_way="`get_configure 免流方式 | grep -wi "^clnc$"`"
    select_mode_file="`get_configure 选择模式`"
    check_extranet_way="`get_configure 检测联网 | grep -Ei "^[abcd]$"`"
    check_extranet_udp="`get_configure 检测UDP联网 | grep -w "^开启$"`"
    quickly_open_scripts="`get_configure 快速启动 | grep -w "^开启$"`"
    on_off_network="`get_configure 开关数据 | grep -w "^开启$"`"
    
    # 判断模块文件夹是否存在MLBox
    if [ -s ${module_path}/MLBox ]; then
        alias MLBox="${module_path}/MLBox"
        is_MLBox_exist="true"
    fi
    
    # 查看模式文件状态，正常为空
    if [[ `find "${mode_path}" -type f -maxdepth 1 -iname "*.conf"` ]]; then
        # 判断是否指定了模式名
        if [[ ${select_mode_file} ]]; then
            mode_file="${select_mode_file}.conf"
            # 判断是否找到配置里选择的模式文件
            [[ ! `find "${mode_path}" -type f -maxdepth 1 -name "${mode_file}"` ]] && mode_file_state="no_selected_mode_file"
        else
            mode_file="*.conf"
            # 判断是否有多个模式文件
            [ 1 -lt `find "${mode_path}" -type f -maxdepth 1 -iname "${mode_file}" | grep -c ".conf$"` ] && mode_file_state="please_select"
        fi
        
        if [[ ! ${mode_file_state} ]]; then
            # 判断模式文件有没有内容，有就为正常
            if [ ! -s ${mode_path}/${mode_file} ]; then
                mode_file_state="no_content"
            else
                mode_file_state="normal"
                # 模式正常就重写模式路径
                mode_file="`find "${mode_path}" -type f -maxdepth 1 -name "${mode_file}"`"
                
                # 如果执行检测.sh就读取端口
                [[ ! ${script_execution_state} ]] && read_mode_port
            fi
        fi
        
    else
        # 没找到模式文件
        mode_file_state="no_mode_file"
    fi
    
    return 0
}


# 关闭防跳 []<-()
close_zjl() {
    # 关闭核心    
    `pkill tiny`
    `pkill clnc`
    
    # 清理ip路由规则
    ip rule del fwmark 0x4f5da2/0xffffffff table 100
    ip route del local default dev lo table 100
    
    # 解除禁止ipv6
    ip -6 rule del pref 13001 unreachable
    
    #清除iptables规则        
    iptables -t nat -F OUTPUT
    iptables -t nat -F PREROUTING
    iptables -t mangle -F PREROUTING
    
    for ZJL in OUTPUT FORWARD; do
        iptables -t mangle -F ${ZJL}
        iptables -t mangle -P ${ZJL} ACCEPT
    done
    
    # 释放网络
    iptables -D OUTPUT ! -o wlan+ -j DROP
    iptables -D OUTPUT `iptables -L OUTPUT -t filter --line-numbers | sed -n 's/\([0-9]\) .*! owner GID match.*/\1/p'`
    iptables -D FORWARD -j DROP
    
    # 调用开机自启函数
    boot_auto_on
}


# 开启防跳 [Boolean]<-()
open_zjl() {
    # 如果模式为不正常，就退出函数
    [[ "normal" != ${mode_file_state} ]] && return 1
    
    # 读取模式及端口
    read_mode_port
    
    # 获取GID 启动核心
    if [[ "clnc" == ${unlimited_data_way} ]]; then
        # 处理模式 注释Tun部分
        `echo "${mode_file_content}" | grep -qw "tunDevice"` && `sed -i 's/tunDevice[ ]*=/\/\/&/g' ${mode_file}`
        forward_gid="3004"
        
        # 禁止网络 改为放行GID
        iptables -D OUTPUT ! -o wlan+ -j DROP
        iptables -I OUTPUT ! -o wlan+ -m owner ! --gid ${forward_gid} -j DROP
        
        # 以GID方式 启动clnc核心
        ${module_path}/clnc -g ${forward_gid} -c ${mode_file} 1>&2
    else
        forward_gid="`echo "${mode_file_content}" | grep -w "user" | sed -r "s/[ ][ ]*//g;s/.*=(.*)\;/\1/;s/root/0/;s/inet/3003/;s/net_raw/3004/"`"
        forward_gid=${forward_gid:="`echo "${mode_file_content}" | grep -w "uid" | sed -r "s/[ ][ ]*//g;s/.*=(.*)\;/\1/"`"}
        forward_gid=${forward_gid:="0"}
        unlimited_data_way="tiny"
        
        # 使用MLBox以GID方式 启动tiny核心
        `MLBox -cmd="${forward_gid} ${module_path}/tiny -c ${mode_file}"`
    fi
        
    # 如果核心没开启，就退出函数
    [[ ! `pgrep ${unlimited_data_way}` ]] && return 2
    
    # 打开ipv4路由转发
    echo '1' > /proc/sys/net/ipv4/ip_forward
    echo '1' > /proc/sys/net/ipv4/ip_dynaddr
    
    # 判断是否启动TCP_FASTOPEN
    [[ "clnc" == ${unlimited_data_way} && `echo "${mode_file_content}" | grep '^ *tcp_option *= *TFO'` ]] && echo '3' >/proc/sys/net/ipv4/tcp_fastopen
        
    # 通过ip路由禁止ipv6
    [[ "放行" != `get_configure 手机IPv6` ]] && ip -6 rule add pref 13001 unreachable
    
    # 调用核心部分的iptables规则
    important_rules
    # 调用次要部分的iptables规则
    not_important_rules
    
    return 0
}


# 显示输出界面 []<-()
show_display() {
    # 分割线
    dividing_line="—————————————————————————\n"    
    
    # 输出两个空行
    echo "\n"
    
    output_dividing_line
    center_output "ZJL 2.0\n"
    [[ ! ${is_busybox_exist} ]] && center_output "无 BusyBox 使用  \n"
    [[ ${is_udp_supported} ]] && center_output "本机不支持 UDP 代理  \n"
    output_dividing_line
    
    # 输出当前使用的免流核心状态
    if [[ `pgrep tiny` ]]; then
        center_output "核心: tiny √\n"
    elif [[ `pgrep clnc` ]]; then
        center_output "核心: clnc √\n"
    else
        center_output "核心: 什么都没开 × \n"
        # 没开免流关闭检测网络
        check_extranet_way=""
        check_extranet_udp=""
    fi
    
    # 判断当前模式是否正常
    if [[ "normal" == ${mode_file_state} ]]; then
        # 如果 填选了模式文件 就输出模式名
        [[ ${select_mode_file} ]] && center_output "模式: ${select_mode_file}.conf\n"
    elif [[ "" != ${mode_file_state} ]]; then
        output_dividing_line
        
        # 输出模式文件当前状态
        case ${mode_file_state} in
            no_selected_mode_file)
                center_output "没找到 ${select_mode_file}.conf\n"
                center_output "请去 [选择模式] 里重填 !\n"
            ;;
            please_select)
                find "${mode_path}" -type f -maxdepth 1 -iname "*.conf" | while read ZJL; do
                    center_output "模式: ${ZJL##*/}\n"
                done
                center_output "请使用 [选择模式] 功能 !\n"
            ;;
            no_content)
                center_output "模式内容为空 !\n"
            ;;
            no_mode_file)
                center_output "请添加模式 !\n"
            ;;
        esac
        
        output_dividing_line
    fi

    # 判断是否开启快速启动功能
    if [[ ! ${quickly_open_scripts} ]]; then
        # 获取网卡和IP
        local network_info="`ip route | grep -Ev "tun|TUN|192.168.43." | sed 's/proto kernel scope link //' | sed -r 's/.*dev (.*) src (.*)/\1 \2/'`"
        
        # 判断当前使用的是否为WiFi
        if [[ `echo "${network_info}" | grep wlan` ]]; then
            # 模式正常就输出一个分割线
            [[ "normal" == ${mode_file_state} ]] && output_dividing_line
            
            center_output "网络: WIFI 已连接 √\n"
            #获取WIFI的网卡
            local network_card="`echo "${network_info}" | grep -i "wlan" | sed -n 's/ .*//;1p'`"
            # 获取WiFi SSID
            local wifi_name="`dumpsys netstats | grep -i "iface" | grep -i "${network_card}" | sed -n 's/.*networkId="\(.*\)".*/\1/g;1p'`"
            
            if [[ ${wifi_name} ]]; then
                # 输出 WiFi名字
                center_output "名称: ${wifi_name}\n"
                
                # 获取WiFi密码
                if [ -s /data/misc/apexdata/com.android.wifi/WifiConfigStore.xml ]; then
                    wifi_password="`grep -wA 3 '<string name="SSID">&quot;'${wifi_name}'' /data/misc/apexdata/com.android.wifi/WifiConfigStore.xml \
                                    | sed -n 's/\(.*\)<string name="PreSharedKey">&quot;\(.*\)&quot\(.*\)/\2/p'`"
                elif [ -s /data/misc/wifi/WifiConfigStore.xml ]; then
                    wifi_password="`grep -wA 3 '<string name="SSID">&quot;'${wifi_name}'' /data/misc/wifi/WifiConfigStore.xml \
                                    | sed -n 's/\(.*\)<string name="PreSharedKey">&quot;\(.*\)&quot\(.*\)/\2/p'`"
                elif [ -s /data/misc/wifi/wpa_supplicant.conf ]; then
                    wifi_password="`grep -wA 3 'ssid='\"${wifi_name}\"'' /data/misc/wifi/wpa_supplicant.conf | sed -n 's/\(.*\)psk="\(.*\)"\(.*\)/\2/p'`" 
				fi
				
                # 输出 WiFi密码
                [[ ${wifi_password} ]] && center_output "密码: ${wifi_password} \n"
            else
                center_output "获取WiFi名和密码失败 \n"
            fi
            
            # 输出 WiFi 使用流量数
            get_network_card_traffic "${network_card}"
            
        else
            # ———当前使用的是流量———
            
            # 获取内网IP
            local intranet_ip="`echo ${network_info} | grep -Ei "rmnet|ccmni" | sed 's/.* //'`"
            #获取流量的网卡
            local network_card="`echo "${network_info}" | grep -Ei "rmnet|ccmni" | sed 's/ .*//'`"
            
            # 判断是否能读取到流量内网IP
            if [[ ${intranet_ip} ]]; then
                # 只有满足不是关闭防跳  开启了检测功能才会开始检测
                if [[ "close" != ${script_execution_state} ]] && [[ ${check_extranet_way} || ${check_extranet_udp} ]]; then
                    local check_extranet_state="ON"
                    
                    # 判断是否存在MLBox模块
                    if [[ ${is_MLBox_exist} ]]; then
                        # 判断是否开启检测联网功能
                        if [[ ${check_extranet_way} ]]; then
                            # 存储获取到的数据
                            local extranet_ip
                            # 超时时间(单位秒)
                            local time="2"
                            
                            # 通过MLBox检测网络连接
                            case ${check_extranet_way} in
                                a|A)
                                    # ip138 的接口
                                    extranet_ip="`MLBox -http="http://202020.ip138.com/" -t=${time} | grep "来自" \
                                                 | sed 's/\[.*\">//;s/<.*]//;s/.*地址是：/IP：/;s/来自/\n来自/'`"
                                ;;
                                b|B)
                                    # 站长之家 的接口
                                    extranet_ip="`MLBox -http="http://mip.chinaz.com/" -t=${time} | grep -Ei "您的IP|来自" \
                                                 | sed "s/.*<h4>//g;s/<\/.*>//g;s/<.*>//g;s/.*地址：/IP：/"`"
                                ;;
                                c|C)
                                    # cip.cc 的接口
                                    extranet_ip="`MLBox -http="http://www.cip.cc/" -t=${time} | grep -E "<pre>IP|数据二" \
                                                 | sed "s/.*IP.*: /IP：/;s/数据二.*: /来自：/;s/| //"`"
                                ;;
                                d|D)
                                    # ipip.net 的接口
                                    extranet_ip="`MLBox -http="http://myip.ipip.net/" -t=${time} | grep -E "IP|来自"  \
                                                 | sed "s/\/.*\///g;s/<.*>//g;s/当前.*IP：/IP：/;s/来自于：/\n来自：/;s/| //"`"
                                ;;
                            esac
                            
                            # 判断HTTP是否联网成功
                            if [[ ${extranet_ip} ]]; then
                                # 去除前后空格
                                extranet_ip="`echo "${extranet_ip}" | sed "s/^[ \t]*//g;s/[ \t]*$//g"`"
                                local extranet_http="√"
                                # HTTP联网成功了才检测HTTPS
                                [[ ! `MLBox -http="https://im.qq.com/favicon.ico" -t=${time} | grep -Ei "timeout|httpGetResponse"` ]] && local extranet_https="√"
                            fi
                        fi
                        
                        # 判断是否开启检测UDP
                        if [[ ${check_extranet_udp} ]] && [[ ( ! ${check_extranet_way} ) || "√" == ${extranet_http} ]] && [[ ${proxy_native_udp} || ${proxy_hotspot_udp} ]]; then
                            [[ "UDP network is smooth" == `MLBox -udptest=true -t=${time}` ]] && local extranet_udp="√" || local extranet_udp="×"
                        fi
                    else
                        check_extranet_state="MLBoxNoExist"
                    fi
                fi
                
                # 输出内网IP
                center_output "内网: ${intranet_ip}\n"
                
                # 获取 APN 信息
                local apn_info="`dumpsys connectivity | grep "NetworkAgentInfo{" | grep -Ev "ims|IMS|tun|TUN" | sed 's/.*extra: \(.*\)nc{.*/\1/'`"
                # 获取 APN
                local apn="`echo ${apn_info} | sed 's/,.*//'`"
                # 获取APN 代理和端口 信息
                local apn_agent_and_port="`echo ${apn_info}  | sed -rn 's/.*HttpProxy: \[(.*)\] ([0-9]{2,5}).*}/\1 \2/p'`"
                
                # 输出接入点
                [[ ${apn_agent_and_port} ]] && center_output "APN: ${apn} ${apn_agent_and_port}\n" || center_output "APN: ${apn} 代理留空  \n"
                
                # 输出数据使用流量数
                get_network_card_traffic "${network_card}"
                
                # 判断检测联网状态
                case ${check_extranet_state} in
                    ON)
                        # 判断是否开启检测联网功能
                        if [[ ${check_extranet_way} ]]; then
                            output_dividing_line
                            center_output "HTTP 联网 ${extranet_http:="×"}   HTTPS 联网 ${extranet_https:="×"}\n"
                                            
                            if [[ ${extranet_ip} ]]; then
                                echo "${extranet_ip}" | while read ZJL; do
                                    center_output "${ZJL} \n"
                                done
                            else
                                center_output "查询外网IP失败\n"
                            fi
                        fi
                        
                        # 判断是否检测了UDP
                        if [[ ${extranet_udp} ]]; then
                            output_dividing_line
                            center_output "UDP 连接 ${extranet_udp}\n"
                        fi
                    ;;
                    MLBoxNoExist)
                        output_dividing_line
                        center_output "[检测联网]和[检测UDP联网]需要MLBox  \n"
                        center_output "请将MLBox模块复制进模块文件夹  \n"
                    ;;
                esac
                
                # 判断是否开启显示内网白名单功能
                if [[ "close" != ${script_execution_state} && "开启" == `get_configure 显示内网白名单` ]]; then
                    # 读取生效的内网IP白名单列表
                    local intranet_ip_effective_list="`iptables -t mangle -S OUTPUT \
                                                    | grep "^-A.*-p tcp.*-m state --state NEW,RELATED,ESTABLISHED -j ACCEPT$" \
                                                    | grep -E "(\-s ([0-9]{1,3}\.){3}[0-9]{1,3}/16 -p tcp.*)|(iprange --src-range)" \
                                                    | sed -r "s/.*-s(.*)-m.*/\1/;s/rc-range (.*) /\1/;s/ (.*)\/16.*/\1/"`"
                    
                    if [[ ${intranet_ip_effective_list} ]]; then
                        output_dividing_line
                        center_output "生效的内网白名单列表\n"
                        center_output "其他内网将会没网\n"
                    
                        for ZJL in ${intranet_ip_effective_list}; do
                            center_output "${ZJL}\n"
                        done
                    fi
                fi
            else
                center_output "网络: 数据都没开 ×\n"
            fi
            
            # 获取热点信息
            local hotspots_info="`ifconfig | grep -A 7 '192.168.43.'`"
            # 获取热点连接数
            local hotspots_connect="`grep -c '0x2' /proc/net/arp`"
            # 判断热点是否开启
            if [[ ${hotspots_info} || "0" != ${hotspots_connect} ]]; then
                output_dividing_line
                
                # 获取热点连接设备数
                center_output "热点: ${hotspots_connect} 个已连接\n"
                
                # 获取热点的名字和密码
                if [ -s /data/misc/apexdata/com.android.wifi/WifiConfigStoreSoftAp.xml ]; then
                    local hotspot="`grep -E '(<string name="SSID">)|(<string name="Passphrase">)' /data/misc/apexdata/com.android.wifi/WifiConfigStoreSoftAp.xml`"
                    local hotspot_name="`echo "${hotspot}" | sed -n 's/.*name="SSID">\(.*\)<\/string>.*/\1/p'`"
                    local hotspot_password="`echo "${hotspot}" | sed -n 's/.*name="Passphrase">\(.*\)<\/string>.*/\1/p'`"
                elif [ -s /data/misc/wifi/softap.conf ]; then
                    local hotspot="`sed -r $'s/\u0004/\u0020/;s/[\u0001-\u0019]//g' /data/misc/wifi/softap.conf`"
                    local hotspot_name="`echo ${hotspot} | sed $'s/\u0020.*//'`"
                    local hotspot_password="`echo ${hotspot} | sed $'s/.*\u0020//'`"
                fi
                
                # 输出热点信息
                if [[ ${hotspot_name} ]]; then
                    center_output "名称: ${hotspot_name} \n"
                    [[ ${hotspot_password} ]] && center_output "密码: ${hotspot_password}  \n"
                else
                    center_output "获取热点名和密码失败 \n"
                fi
                
                # 判断是否存在busybox
                if [[ ${is_busybox_exist} ]]; then
                    # 获取共享网络使用流量数
                    local flow="`echo "${hotspots_info}" | grep 'TX bytes' | sed 's/.*TX bytes:.*(\(.*B\)).*/\1/;s/i.*//'`"
                    # 输出共享网络使用流量数
                    [[ "0.0 B" == ${flow} || "" == ${flow} ]] && center_output "已用: 没查到 ×\n" || center_output "已用: ${flow}\n"
                fi
            fi
            
        fi
    fi
    
    # 获取小尾巴内容
    local output_tail="`echo "${configure_file_content#*小尾巴=}"`"
    # 输出小尾巴内容
    if [[ ${output_tail} ]]; then
        output_dividing_line
        echo "${output_tail}" | while read ZJL; do
            center_output "${ZJL}  \n"
        done
    fi
    
    output_dividing_line
}


# 主函数 []<-(option...)
main() {
    # 保存参数
    options="${*} "
    
    # 判断选项是否合法
    if [[ `echo "${options}" | grep -E "^((-[ocdihv][ ])|(--(open|kill|display|info|help|version)[ ])){1,3}$"` ]]; then
        if [[ `echo "${options}" | grep -E '(\-h)|(\-\-help)'` ]]; then
            [[ "1" == ${#} ]] && show_help || show_help "-h 或者 --help 只能单独使用"            
        elif [[ `echo "${options}" | grep -E '(\-v)|(\-\-version)'` ]]; then
            [[ "1" == ${#} ]] && echo "ZJL 防跳 ${zjl_version}" || show_help "-v 或者 --version 只能单独使用"            
        else
            # 显示帮助
            [[ `echo "${options}" | grep -E '(\-o)|(\-\-open)' | grep -E '(\-c)|(\-\-close)'` ]] && show_help "不可以同时执行开启和关闭，-o 和 -c 二选一"
        fi
    else
        # 显示帮助
        show_help "参数错误，只支持1-3个有效参数"
    fi  2>/dev/null
    
    # 防跳主体部分
    mainBody() {
        # 判断当前脚本执行状态
        if [[ `echo "${options}" | grep -E '(\-o)|(\-\-open)'` ]]; then
            script_execution_state="open"
            # 禁止网络
            iptables -I OUTPUT ! -o wlan+ -j DROP
            iptables -I FORWARD -j DROP
        elif [[ `echo "${options}" | grep -E '(\-c)|(\-\-close)'` ]]; then
            script_execution_state="close"
        fi
        
        # 初始化
        init_zjl
        
        # 判断初始化状态
        if [[ "1" == ${?} ]]; then
            # 关闭数据
            svc data disable
            # 释放网络
            iptables -D OUTPUT ! -o wlan+ -j DROP
            iptables -D FORWARD -j DROP
            # 退出脚本
            exit
        fi
        
        if [[ "open" == ${script_execution_state} ]]; then
            # 打开数据
            switch_network "open"
            # 关闭防跳
            close_zjl
            # 打开防跳
            open_zjl
            # 判断启动状态码 不正常就关闭数据
            [[ "0" != ${?} ]] && svc data disable
            # 释放网络
            iptables -D OUTPUT ! -o wlan+ -j DROP
            iptables -D OUTPUT ! -o wlan+ -m owner ! --gid ${forward_gid} -j DROP
            #iptables -D OUTPUT `iptables -L OUTPUT -t filter --line-numbers | sed -n 's/\([0-9]\) .*! owner GID match.*/\1/p'`
            iptables -D FORWARD -j DROP
        elif [[ "close" == ${script_execution_state} ]]; then
            # 关闭数据
            switch_network "close"
            # 关闭防跳
            close_zjl
        fi
        
        # 判断是否显示界面
        [[ `echo "${options}" | grep -E '(\-d)|(\-\-display)'` ]] && show_display
    }
    
    # 判断是否显示错误输出
    [[ `echo "${options}" | grep -E '(\-i)|(\-\-info)'` ]] && mainBody || mainBody 2>/dev/null
}


# 调用主函数
main ${*}